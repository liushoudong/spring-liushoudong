Spring

数据访问
  1、JDBC
    数据源配置
      单数据源配置：
        Spring Boot做了哪些配置：
          DataSourceAutoConfiguration 配置DataSource
          DataSourceTransactionManagerAutoConfiguration 配置DataSourceTransactionManager
          JdbcTemplateAutoConfiguration 配置JdbcTemplate
      多数据源配置：
        不同数据源的配置要分开
        关注每次使用的数据源：有多个DataSource时系统如何判断；对应的设施(事务、ORM等如何选择DataSource)
        方式：
          手工配置
          与Spring Boot协同工作：
            配置@Primary类型的Bean
            排除Spring Boot的自动配置：DataSourceAutoConfiguration；DataSourceTransactionManagerAutoConfiguration；JdbcTemplateAutoConfiguration
  2、连接池
      HikariCP
        
      Alibaba Druid
        
  3、通过Spring JDBC访问数据库
      spring-jdbc
        core，JdbcTemplate等相关核心接口和类
        datasource，数据源相关的辅助类
        object，将基本的JDBC操作封装成对象
        support，错误码等其他辅助工具
      通过注解定义Bean
        @Component
        @Respository
        @Service
        @Controller @RestController
      Jdbc Template
        query
        queryForObject
        queryForList
        update
        execute
    
    事务抽象
      Platform TransactionManager: DataSourceTransactionManager;HibernateTransactionManager;JtaTransactionManager
      TransactionDefinition: Propagation;Isolation;Timeout;Read-only status
      
      事务传播特性
      PROPAGATION_REQUIRED               0
      PROPAGATION_SUPPORTS               1
      PROPAGATION_MANMDATORY             2
      PROPAGATION_REQUIRES_NEW           3
      PROPAGATION_NOT_SUPPORTED          4
      PROPAGATION_NEVER                  5
      PROPAGATION_NESTED                 6
    
      隔离性
      
      编程式事务
        TransactionTemplate:TransactionCallback, TransactionCallbackWithoutResult
      声明式事务
        基于注解的配置方式
          开启事务注解的方式 @EnableTransactionManagement
          一些配置
            proxyTargetClass：基于接口的还是基于类的  有接口的话使用proxy，没有接口使用CGLIB
            mode：是否使用ASPECTJ
            order：优先级
          @Transactional
            transactionManager
            propagation
            isolation
            timeout
            readOnly
            怎么判断回滚
            
          
    JDBC异常抽象

  O/R Mapping
    Spring Data JPA
    定义JPA的实体对象
    Repository是怎么从接口变成Bean的
    通过Mybatis

  NoSQL
    Spring访问MongoDB
    Spring访问Redis
    Spring缓存抽象
    

Spring MVC
  
Web开发

服务注册与发现
  consul
    Consul is a distributed，highly available， and data center aware solution to connect and configure applications across dynamic, distributed infrastructure
  关键特性
    服务发现
    健康检查
    KV存储
    多数据中心支持
    安全的服务间通信

服务熔断

服务配置



Spring Boot
  1、概览
    更快更好地构建应用程序

    特性：
      方便地创建可独立运行的Spring应用程序
      直接内嵌Tomcat、Jetty或Undertow(JAR包)
      简化了项目的构建配置
      为Spring及第三方库提供自动配置
      提供生产级特性
      无需生成代码或进行XML配置

    Spring Boot的四大核心
      自动配置 - Auto Configuration
      起步依赖 - Starter Dependency
      命令行界面 - Spring Boot CLI
Actuator

2、自动配置
  基于添加的JAR依赖自动对Spring Boot应用程序进行配置 --> spring-boot-autoconfiguration
  开启自动配置：
    @EnableAutoConfiguration (exclude=Class<?>[])
    @SpringBootApplication
  自动配置的实现原理@EnableAutoConfiguration
    AutoConfigurationImportSelector会加载
    META-INF/spring.factories:org.springframework.boot.autoConfigure.EnableAutoConfiguration
  
  通过条件注解实现自动配置：
    @Conditional
    类注解：
      @ConditionalOnClass
      @ConditionalOnMissingClass
    Bean条件：
      @ConditionalOnBean
      @ConditionalOnMissingBean
      @ConditionalOnSingleCandidate
    属性条件：
      @ConditionalOnProperty
    资源条件：
      @ConditionalOnResource
    Web应用条件：
      @ConditionalOnWebApplication
      @ConditionalOnNotApplication
    其他条件：
      @ConditionalOnExpression
      @ConditionalOnJava
      @ConditionalOnJndi
    ......
    自动配置的执行顺序：
      @AutoConfigureBefore
      @AutoConfigureAfter
      @AutoConfigureOrder
    
  了解自动配置的判断结果 --debug
    ConditionEvaluationReportLoggingListener
      Positive matches
      Negative matches
      Exclusions
      Unconditional classes
      
    实现自动配置：
      编写Java Config：@Configuration
      添加条件：@Conditional
      定位自动配置：META-INF/spring.factories
  
  低版本实现自动配置
    核心思路：
      条件判断：通过BeanFactoryPostProcessor进行判断
    配置加载：
      编写Java Config类
      引入配置类：
        通过component-scan
        通过XML文件import
        
  配置加载机制
    外化配置加载顺序：
      开启DevTools时，~/.spring-boot-devtools.properties
      测试类上的@TestpropertySource注解
      @SpringBootTest#properties属性
      命令行参数(--server.port=9000)
      SPRING_APPLICATION_JSON中的属性
      ServletConfig初始化参数
      ServletContext初始化参数
      Java:comp/env中的JNDI属性
      System.getProperties()  --> Java -D参数指定的系统属性
      操作系统环境变量
      random.*涉及到的RandomValuePropertySource
      jar包外部的application-{profile}.properties或.yml
      jar包内部的application-{profile}.properties或.yml
      jar包外部的application.properties或.yml
      jar包内部的application.properties或.yml
      @Configuration类上的@PropertySource
      SpringApplication.setDefaultProperties()设置的默认属性
      
   application.properties
    默认位置：
      ./config
      ./
      CLASSAATH中的/config
      CLASSPATH中的/
    修改名字或路径：
      spring.config.name
      spring.config.location
      spring.config.additional-location
      
  PropertySource抽象
  
  Spring的两个扩展点：
    BeanPostProcessor
      针对Bean实例
      在Bean创建后提供定制逻辑回调
    BeanFactoryPostProcessor
      针对Bean定义
      在容器创建Bean前获取配置元数据
      Java Config中需要定义为static方法
      
  关于Bean的一些定制
    Lifecycle Callback
      实现InitializingBean接口/使用注解@PostConstruct/xml配置init-method
      实现DisposableBean接口/使用注解@PreDestroy/xml配置destroy-method
    XxxAware接口
      ApplicationContextAware
      BeanFactoryAware
      BeanNameAware
      
起步依赖 Starter Dependency
  Starter Dependencies
    直接面向功能，一站获得所有相关依赖，不再复制粘贴
  官方的Starters
    spring-boot-starter-*
  定制自己的起步依赖
    autoconfigure模块，包含自动配置代码
    starter模块，包含指向自动配置模块的依赖以及其他相关依赖
    
    




Actuator Endpoint


IoC
  1、IoC主要实现策略
    服务定位模式
    依赖注入：构造器注入、参数注入、Setter注入、接口注入
    依赖查询：beanContext
    模板方法设计模式
    策略模式
    
  2、IoC容器职责
    依赖处理：依赖注入、依赖查找
    生命周期管理：容器、托管的资源（Java Beans或其他资源）
    配置：容器、外部化配置、托管的资源（Java Beans或其他资源）

  3、IoC容器实现
    主要实现：
      Java SE：Java Beans、Java ServiceLoader SPI、JNDI（Java Naming and Directory Interface）
      Java EE：EJB（Enterprise Java Beans）、Servlet
      开源
  
  4、传统IoC容器实现
    Java Beans作为IoC容器
    特性：
      依赖查找
      生命周期管理
      配置元信息
      事件
      自定义
      资源管理
      持久化
    规范：
      JavaBeans
      BeanContext：管理Bean、以及Bean自己容器之间的相互依赖关系，包括层次性
      
    什么才是JavaBean
      可以是一个简单的POJO
      
      POJO            Setter/Getter方法
      JavaBeans       可写方法/可读方法      字段称为Peoperty
    
    BeanInfo beanInfo = Introspector.getBeanInfo(xx.class) 自省
    ProperDescriptor ==> 名称、可写方法、可读方法
    ProperDescriptor允许添加属性编辑器 - PropertyEditor
    PropertyEditorSupport
  
  5、轻量级IoC容器实现
    管理应用代码，可以控制代码的启停、生命周期
    可以快速启动
    不需要特殊的配置
    轻量级的内存占用、最小化的API依赖
    需要一些可以管控的渠道
  
  6、依赖查找 VS. 依赖注入
    类型            依赖处理          实现便利性             代码侵入性           API依赖性          可读性
    依赖查找        主动获取 pull      相对繁琐 查找+注入     侵入业务逻辑          依赖容器API         良好
    依赖注入        被动提供 push      相对便利              低侵入性             不依赖容器API        一般
    
  7、构造器注入 VS. Setter注入
    构造器注入
    Setter注入
  
Spring IoC容器
  1、Spring IoC依赖查找
    // 配置 XML 配置文件
    // 启动 Spring 应用上下文
    BeanFactory beanFactory = new ClassPathXmlApplicationContext("classpath:/META-INF/dependency-lookup-context.xml");
        
    (1) 根据Bean名称查找
      a. 实时查找
        User user = (User) beanFactory.getBean("user");
        
       xml
          <bean id="user" class="org.geekbang.thinking.in.spring.ioc.overview.domain.User">
          <property name="id" value="1"/>
          ......
          </bean>
        
      b. 延迟查找
        ObjectFactory<User> objectFactory = (ObjectFactory<User>) beanFactory.getBean("objectFactory");
        User user = objectFactory.getObject();
        需要注意xml的配置
        xml
          <bean id="objectFactory" class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean">
          <property name="targetBeanName" value="user"/>
          </bean>
          
    (2) 根据Bean类型查找
      a. 单个Bean对象
        User user = beanFactory.getBean(User.class);
      b. 集合Bean对象
        if (beanFactory instanceof ListableBeanFactory) {
            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;
            Map<String, User> users = listableBeanFactory.getBeansOfType(User.class);  //id->bean 
          }
    
    (3) 根据Bean名称+类型查找
    
    (4) 根据Java注解查找
      a. 单个Bean对象
      
      b. 集合Bean对象
        if (beanFactory instanceof ListableBeanFactory) {
            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;
            Map<String, User> users = (Map) listableBeanFactory.getBeansWithAnnotation(Super.class);
        }
        
  ObjectFactory、BeanFactory、FactoryBean区别：
    ObjectFactory没有生成新的bean
    ObjectFactory autowire的时候会自动注入一个ApplicationContext，这里ApplicationContext又是一个BeanFactory
  
  2、Spring IoC依赖注入
  // 配置 XML 配置文件
  // 启动 Spring 应用上下文
  // 有两个上下文同时存在
  BeanFactory beanFactory = new ClassPathXmlApplicationContext("classpath:/META-INF/dependency-injection-context.xml");
  
    (1)根据Bean名称注入
    <!-- 通过导入复用 dependency-lookup-context.xml -->
    <import resource="dependency-lookup-context.xml"/>
    
      <bean id="userRepository" class="org.geekbang.thinking.in.spring.ioc.overview.repository.UserRepository"> 
          <!-- 手动配置 -->
        <property name="users">
          <util:list>
            <ref bean="superUser" />
            <ref bean="user" />
            </util:list>
         </property>
    </bean>
    
    class UserRepository {
        private Collection<User> users; // 自定义 Bean
        public Collection<User> getUsers() {
          return users;
        }
        public void setUsers(Collection<User> users) {
          this.users = users;
        }
    }
    
    
    (2)根据Bean类型注入
      a. 单个Bean对象
      b. 集合Bean对象
      <bean id="userRepository" class="org.geekbang.thinking.in.spring.ioc.overview.repository.UserRepository"
          autowire="byType"> 
      </bean>
    
    (3)注入容器内建Bean对象
      
    
    (4)注入非Bean对象
      class UserRepository {
        private Collection<User> users; // 自定义 Bean
        private BeanFactory beanFactory; // 內建非 Bean 对象（依赖）
        public Collection<User> getUsers() {
          return users;
        }
        public void setUsers(Collection<User> users) {
          this.users = users;
        }
        public void setBeanFactory(BeanFactory beanFactory) {
          this.beanFactory = beanFactory;
        }
        public BeanFactory getBeanFactory() {
          return beanFactory;
        }
    }
    
    (5)注入类型
      a. 实时注入
      
      b. 延迟注入
        class UserRepository {
        private Collection<User> users; // 自定义 Bean
        private BeanFactory beanFactory; // 內建非 Bean 对象（依赖）
        private ObjectFactory<ApplicationContext> objectFactory;
        public Collection<User> getUsers() {
          return users;
        }
        public void setUsers(Collection<User> users) {
          this.users = users;
        }
        public void setBeanFactory(BeanFactory beanFactory) {
          this.beanFactory = beanFactory;
        }
        public BeanFactory getBeanFactory() {
          return beanFactory;
        }
        public ObjectFactory<ApplicationContext> getObjectFactory() {
          return objectFactory;
        }
        public void setObjectFactory(ObjectFactory<ApplicationContext> objectFactory) {
          this.objectFactory = objectFactory;
        }
        
        System.out.println(userFactory.getObject() == beanFactory);
    }
    
  3、Spring IoC依赖来源
    (1)依赖查找、依赖注入的来源不是同一个地方
    (2)依赖来源
      a. 自定义Bean
      b. 容器内建Bean对象
        Environment environment = beanFactory/applicationContext.getBean(Environment.class);
      c. 容器内建依赖 beanFactory注入的
  
  4、Spring IoC配置元信息
    (1)Bean定义配置
      a. 基于XML文件
      b. 基于Properties文件
      c. 基于Java注解
      d. 基于Java API
    (2)IoC容器配置
      a. 基于XML文件
      b. 基于Java注解
      c. 基于Java API
    (3)外部化属性配置
      a. 基于Java注解
    
  5、Spring IoC容器：BeanFactory和ApplicationContext谁才是Spring IoC容器
    BeanFactory
    
    ApplicationContext
      ApplicationContext is BeanFactory
      ApplicationContext 是 BeanFactory的包装类，包装了DefaultListableBeanFactory
    
  6、Spring应用上下文：ApplicationContext除了IoC容器角色还提供哪些特性
    面向切面AOP
    配置元信息
    资源管理
    事件
    国际化
    注解
    Environment抽象
  
  7、使用Spring IoC容器：BeanFactory VS. ApplicationContext
     (1)BeanFactory是Spring底层IoC容器  + XML
        // 创建 BeanFactory 容器
        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
        // XML 配置文件 ClassPath 路径
        String location = "classpath:/META-INF/dependency-lookup-context.xml";
        // 加载配置
        int beanDefinitionsCount = reader.loadBeanDefinitions(location);
        System.out.println("Bean 定义加载的数量：" + beanDefinitionsCount);
        // 依赖查找集合对象
        lookupCollectionByType(beanFactory);
    
    (2)ApplicationContext是具备应用特性的BeanFactory超集 + Annotation
        // 创建 BeanFactory 容器
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
        // 将当前类 AnnotationApplicationContextAsIoCContainerDemo 作为配置类（Configuration Class）
        applicationContext.register(AnnotationApplicationContextAsIoCContainerDemo.class);
        // 启动应用上下文
        applicationContext.refresh();
        // 依赖查找集合对象
        lookupCollectionByType(applicationContext);

        // 关闭应用上下文
        applicationContext.close();
  
  8、Spring IoC容器生命周期：IoC容器起停过程中发生了什么
    启动
    
    运行
    
    停止

Spring Bean基础
  1、定义Spring Bean
    什么是BeanDefinition？ --> BeanDefinition是Spring Framework中定义Bean的配置元信息接口，包含：
      a. Bean的类名 -> 对应的类必须是一个具体的实现类?
      b. Bean行为配置元素，如作用域、自动绑定的模式、生命周期回调等
      c. 其他Bean引用，又可称作合作者（Collaborators）或者依赖（Dependencies）
      d. 配置设置，比如Bean属性（Properties）
    
  2、BeanDefinition元信息
    Class -- Bean全类名，必须是具体类，不能用抽象类或接口
    Name -- Bean的名称或者id
    Scope -- Bean的作用域（如：singleton单例模式、prototype原型模式等）
    Constructor arguments -- Bean构造器参数（用于依赖注入）构造器注入
    Properties -- Bean属性设置（用于依赖注入）setter注入
    Autowiring mode -- Bean自动绑定模式（如：通过名称byName）
    Lazy initialization mode -- Bean延迟初始化模式（延迟和非延迟）
    Initialization method -- Bean初始化回调方法名称
    Destruction method -- Bean销毁回调方法名称
  
    BeanDefinition构建
      (1)通过BeanDefinitionBuilder
        builder
          genericBeanDefinition 一般性的BeanDefinition
            a. 通过BeanDefinitionBuilder构建: BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(xx.class)
            b. 通过属性设置: beanDefinitionBuilder.addPropertyValue("name", "value").addPropertyValue()......;
            c. 获取BeanDefinition实例: BeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition(); 
            --> BeanDefinition并非Bean终态，可以自定义进行修改
          
          rootBeanDefinition 顶层的BeanDefinition
          
      (2)通过AbstractBeanDefinition以及派生类
        GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();
        设置Bean类型 genericBeanDefinition.setBeanClass(xx.class);
        通过MutablePropertyValues批量操作属性: 
          MutablePropertyValues propertyValues = new MutablePropertyValues();
          propertyValues.addPropertyValue("name", "value"); 或者propertyValues.add("name", "value").add()......
          genericBeanDefinition.setPropertyValues(propertyValues);通过set MutablePropertyValues批量操作属性
          
  3、命名Spring Bean
    Bean的名称：每个Bean拥有一个或多个标识符，这些标识符在Bean所在的容器必须是唯一的。通常，一个Bean仅有一个标识符，如果需要额外的，可考虑使用别名来扩充。
    在基于XML的配置元信息中，开发人员可用id或者name属性来规定Bean的标识符。通常Bean的标识符由字母组成，允许出现特殊字符。如果想要引入Bean的别名的话，
    可在name属性使用半角逗号或分号来间隔。Bean的id或name属性并非必须制定，如果留空的话，容器会为Bean自动生成一个唯一的名称。Bean的命名尽管没有限制，不过官方建议采用驼峰的方式。
  
   Bean名称生成器(BeanNameGenerator):Spring FrameWork 2.0.3引入，框架内建两种实现
      DefaultBeanNameGenerator: 默认通用BeanNameGenerator实现
      AnnoationBeanNameGenerator: 基于注解扫描的BeanNameGenerator实现
    
  4、Spring Bean的别名
    Bean别名的价值：复用现有的BeanDefinition，更具有场景化的命名方法
    
  5、注册Spring Bean -> 和BeanDefinition的区别
    BeanDefinition注册
      (1)XML配置元信息: <bean name="......"/>
        
      
      (2)Java注解配置元信息: 
        // 创建 BeanFactory 容器
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
        // 注册 Configuration Class（配置类）
        applicationContext.register(AnnotationBeanDefinitionDemo.class);
        
         a. @Bean 
          将bean放在一个配置类中，注册这个配置类
          applicationContext.register(Config.class)
          
          public static class Config{
              @Bean
              public User user() {
              
              }
          }
         b. @Component 
            定义某个类为Spring bean
            
            
         c. @Import 
            @Import(Config.class)
         
      
      (3)Java API配置元信息: 
        a. 命名方式: BeanDefinitionRegistry#registerBeanDefinition(String, BeanDefinition)
          BeanDefinitionBuilder beanDefinitionBuilder = genericBeanDefinition(User.class);
          beanDefinitionBuilder
                .addPropertyValue("id", 1L)
                .addPropertyValue("name", "小马哥");
          // 注册 BeanDefinition
          registry.registerBeanDefinition(beanName, beanDefinitionBuilder.getBeanDefinition());
        
        b. 非命名方式: BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition, BeanDefinitionRegistry)
          // 非命名 Bean 注册方法
            BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinitionBuilder.getBeanDefinition(), registry);
        
        c. 配置类方式: AnnotatedBeanDefinitionReader#register(Class...)
      
        在Spring容器中，Bean不会重复注册
    
  6、实例化Spring Bean -> 将BeanDefinition实例化为一个bean
    Bean实例化
      (1)常规方式: 
        a. 通过构造器(配置元信息: XML、Java注解和Java API)
        
        b. 通过静态工厂方法(配置元信息: XML和Java API) -> 工厂
        
        c. 通过Bean工厂方法(配置元信息: XML和Java API) -> 抽象工厂
        
        d. 通过FactoryBean(配置元信息: XML、Java注解和Java API) 
        
      (2)特殊方式
        a. 通过ServiceLoaderFactoryBean(配置元信息: XML、Java注解和Java API)
        
        b. 通过AutowrieCapableBeanFactory#createBean(java.lang.class, int, boolean)
        
        c. 通过BeanDefinitionRegistry#registerBeanDefinition(String, BeanDefinition)
      
  7、初始化Srping Bean -> 
    Bean初始化
      (1). @PostConstruct标注方法
      
      (2). 实现InitialzingBean接口的afterPropertiesSet()方法
    
      (3). 自定义初始化方法
        a. XML配置: <bean init-method='init'.../>
        
        b. Java注解: @Bean(initMethod="init")
        
        c. Java API: AbstractBeanDefinition#setInitMethodName(String)
          
     
      假设以上三种方式均在同一Bean中定义，执行顺序
      顺序:@PostConstruct标注方法 -> 实现InitialzingBean接口的afterPropertiesSet()方法 -> 自定义初始化方法
        
    
    延迟初始化的Bean会影响依赖注入吗？
      
      Bean延迟初始化
        (1) XML配置: <bean lazy-init="true" .../>
        (2) Java注解: @Lazy(true)
        
      当某个bean定义为延迟初始化，那么，spring容器返回的对象与非延迟的对象存在怎样的差异      
        非延迟初始化在Spring应用上下文启动完成后，被初始化
        延迟初始化是在Spring应用上下文启动后依赖查找的时候触发，按需    
      
      
  8、销毁Spring Bean
    Bean销毁
      (1) @PreDestroy标注方法
    
      (2) 实现DisposableBean接口的destroy()方法
    
      (3) 自定义销毁方法
        a. XML配置: <bean destroy="destroy".../>
        
        b. Java注解: @Bean(destroy="destroy")
        
        c. Java API: AbstractBeanDefinition#setDestroyMethodName(String)
        
      执行顺序:@PreDestroy -> 实现DisposableBean接口的destroy()方法 -> 自定义销毁方法
      
      close 方法触发销毁
        
  9、垃圾回收Spring Bean
     Bean垃圾回收(GC)
      (1) 关闭Spring容器(应用上下文)
      (2) 执行GC
      (3) Spring Bean覆盖的finalize()方法回调
      
Spring IOC依赖查找
  1、依赖查找的今世前生
    单一类型依赖查找
      JNDI - javax.naming.Context#lookup(javax.naming.Name)
      JavaBeans - java.beans.beancontext.BeanContext
      
    集合类型依赖查找
      java.beans.beancontext.BeanContext
      
    层次性依赖查找
      java.beans.beancontext.BeanContext
      
    
  2、单一类型依赖查找 - BeanFactory
    java.beans.beancontext.BeanContext
    (1) 根据Bean名称查找
      getBean(String)
      Spring 2.5覆盖默认参数: getBean(String, Object...) 
      
    (2) 根据Bean类型查找
      a. Bean实时查找
        Spring 3.0 getBean(Class)
        Spring 4.1 覆盖默认参数: getBean(Class, Object...)
      
      b. Spring 5.1 Bean延迟查找
        ObjectProvider<String> objectProvider = applicationContext.getBeanProvider(String.class);
        
        getBeanProvider(Class)
        getBeanProvider(ResolvableType)
      
    (3) 根据Bean名称 + 类型查找
      getBean(String, Class)
    
    
  3、集合类型依赖查找
    java.beans.beancontext.BeanContext
    
    集合类型依赖查找接口-ListableBeanFactory
    
      (1). 根据Bean类型查找
        
        获取同类型的Bean名称列表 -> 判断bean是否存在，使用这个
          getBeanNamesForType(Class)
          Spring 4.2 getBeanNamesForType(ResolvableType)
        
        获取同类型的Bean实例列表 -> 可能会触发bean初始化
          getBeansOfType(Class)以及重载方法
      
      (2). 通过注解类型查找
        Spring 3.0 获取标注类型Bean名称列表
          getBeanNamesForAnnotation(Class<? extends Annotation>)
        Spring 3.0 获取标注类型Bean实例列表
          getBeansWithAnnotation(Class<? extends Annotation>)
        Spring 3.0 获取指定名称 + 标注类型Bean实例
    
  4、层次性依赖查找
    java.beans.beancontext.BeanContext
    
    层次性依赖查找接口 - HierarchicalBeanFactory
      (1). 双亲BeanFactory: getParentBeanFactory()
      (2). 层次性查找:
        a. 根据Bean名称查找
          基于containsLocalBean方法实现 -> local 本地的 当前BeanFactory(IoC容器)所包含的bean，不包含父类中的bean
        
          // 1. 获取 父HierarchicalBeanFactory <- ConfigurableBeanFactory <- ConfigurableListableBeanFactory子
          ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();
          // 2. 设置 Parent BeanFactory
          HierarchicalBeanFactory parentBeanFactory = createParentBeanFactory();
          beanFactory.setParentBeanFactory(parentBeanFactory);
        
        b. 根据Bean类型查找实例列表
          单一类型: BeanFactoryUtils#beanOfType
          集合类型: BeanFactoryUtils#beansOfTypeIncludingAncestors
        
        c. 根据Java注解查找名称列表
          BeanFactoryUtils#beanNamesForTypeIncludingAncestors
    
  5、延迟依赖查找
    Bean延迟依赖查找接口
      org.springframework.beans.factory.ObjectFactory
      
      org.springframework.beans.factory.ObjectProvider
        Spring 5 对 Java 8特性扩展
          函数式接口
            getIfAvailable(Supplier)
            ifAvailable(Consumer)
          Stream扩展 - stream()
    
  6、安全依赖查找
    依赖查找安全性对比
      依赖查找类型              代表实现                        是否安全
      单一类型查找           BeanFactory#getBean                否
                           ObjectFactory#getObject            否
                           ObjectProvider#getIfAvailable      是
      
      集合类型查找           ListableBeanFactory#getBeansOfType 是
                           ObjectProvider#stream              是
                           
      层次性依赖查找的安全性取决于其扩展的单一或集合类型的BeanFactory接口
      
    类型安全
    非安全
    
  7、内建可查找的依赖
    AbstractApplicationContext(所有应用上下文的基类)内建可查找的依赖
    
    Bean名称                             Bean实例                       使用场景
    environment                       Environment对象                 外部化配置以及Profiles
    systemProperties                 java.util.Properties对象         Java系统属性
    systemEnvironment                java.util.Map对象                操作系统环境变量
    messageSource                    MessageSource对象                国际化文案
    lifecycleProcessor               LifecycleProcessor对象           Lifecycle Bean处理器
    applicationEventMulticaster      ApplicationEventMulticaster对象  Spring事件广播器
    
    注解驱动Spring应用上下文内建可查找的依赖
    Bean名称                                        Bean实例                                      使用场景
    org.springframework.context.               ConfigurationClassPostProcessor对象           处理Spring配置类
    annotation.internalConfiguration
    AnnotationProcessor
    
    org.springframework.context.               AutowiredAnnotationBeanPostProcessor对象      处理@Autowired以及@Value注解
    annotation.internalAutowired
    AnnotationProcessor
    
    org.springframework.context.               CommonAnnotationBeanPostProcessor对象         (条件激活)处理JSR-250注解，如@PostConstruct等
    annotation.internalCommon 
    AnnotationProcessor
    
    org.springframework.context.               EventListenerMethodProcessor对象              处理@EventListener的Spring事件监听方法
    event.internalEventListener
    Processor
    
    org.springframework.context.               DefaultEventListenerFactory对象              @EventListener事件监听方法是适配为ApplicationListener
    event.internalEventListenerFactory
     
    org.springframework.context.annotation     PersistenceAnnotationBeanPostProcessor对象   (条件激活)处理JPA注解场景
    .internalPersistenceAnnotationProcessor
    
    
  8、依赖查找中的经典异常
    
  

Spring IOC依赖注入
  
  1、依赖注入的模式和类型
    手动模式：配置或者编程的方式，提前安排注入规则
      XML资源配置元信息  
      Java注解配置元信息        
      API配置元信息
      
    自动模式：实现方提供依赖自动关联的方式，按照内建的注入规则
      AutoWiring 自动绑定
      
    依赖注入类型：
        类型                  配置元数据举例
      Setter方法        <property name="user" ref="userBean">
      构造器            <constructor-arg name="user" ref="userBean">
      字段              @Autowired User user
      方法              @Autowired public void user(User user){...}
      接口回调           class MyBean implements BeanFactoryAware{...}
    
    
  2、自动绑定 AutoWiring
    有效地减少一些属性或者参数的设定
    AutoWiring modes
       模式                   说明
      no              默认值，未激活AutoWiring，需要手动指定依赖注入对象
      byName          根据被注入属性的名称作为Bean名称进行依赖查找，并将对象设置到该属性
      byType          根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性
      constructor     特殊byType类型，用于构造器参数
    限制不足：
  
  3、Setter方法依赖注入
    实现方法
      手动模式
        XML资源配置元信息
          DefaultListableBeanFactory
          XmlBeanDefinitionReader
        Java注解配置元信息
          创建BeanFactory容器
          注册Configuration Class 配置类
          启动Spring应用上下文
          关闭Spring应用上下文
        API配置元信息
          BeanDefinitionBuilder
            addPropertyValue
            addPropertyReference
        
      自动模式
        byName
        byType
        
      缺陷：执行顺序是不确定的
  
  4、构造器依赖注入 --> 执行顺序按照参数顺序
    实现方法
      手动模式
        XML资源配置元信息
          DefaultListableBeanFactory
          XmlBeanDefinitionReader
        Java注解配置元信息
          创建BeanFactory容器
          注册Configuration Class 配置类
          启动Spring应用上下文
          关闭Spring应用上下文
        API配置元信息
          BeanDefinitionBuilder
            addConstructorArgReference
            addConstructorArgValue
     自动模式
        constructor
          特殊的byType方式，仅用于构造器的参数注入
  
  5、字段注入
    实现方法
      手动模式
        Java注解配置元信息 
          @Autowired -> 会忽略掉静态字段
            创建BeanFactory容器
            注册Configuration Class 配置类
          @Resource
          通过byType的方式进行依赖查找
          @Inject JSR-330
  
  6、方法注入 方法参数的方式 byType
    实现方式
      手动模式
        Java注解配置元信息
          @Autowired
          @Resource
          @Inject
          @Bean
  
  7、接口回调注入
    Aware系列接口回调 -> 某某的意识接口
      自动模式
            内建接口                            说明
        BeanFactoryAware                获取当前IoC容器-BeanFactory
        ApplicationContextAware         获取当前Spring应用上下文-ApplicationContext对象
        EnvironmentAware                获取Environment对象
        ResourceLoaderAware             获取资源加载器对象 - ResourceLoader
        BeanClassLoaderAware            获取加载当前 Bean Class的ClassLoader
        BeanNameAware                   获取当前Bean的名称
        MessageSourceAware              获取MessageSource对象，用于Spring国际化
        ApplicationEventPublisherAware  获取ApplicationEventPublisherAware对象，用于Spring事件
        EmbeddedValueResolverAware      获取StringValueResolver对象，用于占位符处理
        
  8、依赖注入类型选择
    注入选型
      低依赖、强制依赖注入：构造器注入
      多依赖：Setter方法注入 缺点：注入的时机的先后顺序完全依赖用户操作
      便利性：字段注入 @Autowired
      声明类：方法注入 @Bean
      
  9、基础类型注入
    基础类型
      原生类型(Primitive): boolean、byte、char、short、int、float、long、double
      标量类型(Scalar): Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID
      常规类型(General): Object、String、TimeZone、Calendar、Optional等
      Spring类型: Resource、InputSource、Formatter等
      
    输进去的是一个字符类型，输出的却是xx类型-->类型转换
  
  10、集合类型注入
    集合类型
      数组类型Array：原生类型、标量类型、常规类型、Spring类型
      集合类型Collection：
        Collection：List、Set(SortedSet、NavigableSet、EnumSet)
        Map：properties
      
 
  11、限定注入
    使用注解@Qualifier限定
      通过Bean名称限定
      通过分组限定
      
    基于注解@Qualifier扩展限定
      自定义注解 - 如Spring Cloud @LoadBalanced
  
  12、延迟依赖注入
    使用API ObjectFactory延迟注入
      单一类型
      集合类型
    
    使用API ObjectProvider延迟注入
      单一类型
      集合类型
    
  13、依赖处理过程

  14、@Autowired注入原理
    @Autowired注入过程
   
      (1). 元信息解析  -->  谁要进行注入
         DependencyDescriptor 
      
      (2). 依赖查找  -->  查找出依赖的来源
      
      (3). 依赖注入(字段、方法)  -->  注入的对象
  
  15、JSR-330 @Inject注入 
  
  16、@Resource、@EJB原理
  
  17、自定义依赖注入注解
  

Spring IoC依赖来源
  依赖查找的来源
    
  依赖注入的来源
    
  Spring容器管理和游离对象
    
  Spring Bean Definition作为依赖来源
    
  单例对象作为依赖来源
    
  非Spring容器管理对象作为依赖来源
    
  外部化配置作为依赖来源
    

Spring Bean作用域
  Spring Bean作用域
    
  “singleton” Bean作用域
  “prototype” Bean作用域
  
  
  “request” Bean作用域
  “session” Bean作用域
  “application” Bean作用域
  自定义Bean作用域
  
  
Spring Bean生命周期
  1、Spring Bean元信息配置阶段 -> 通过配置资源或者配置资源对BeanDefinition进行配置
    BeanDefinition配置
      (1) 面向资源 
          a. XML配置; 
          b. Properties资源配置;   
            DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
            // 实例化基于 Properties 资源 BeanDefinitionReader
            PropertiesBeanDefinitionReader beanDefinitionReader = new PropertiesBeanDefinitionReader(beanFactory);
          c. Grovvy
      (2) 面向注解 
          a. @Configuration 
          b. @Component 
          c. @Bean
      (3) 面向API 
          BeanDefinitionBuilder BeanDefinition
      
  2、Spring Bean元信息解析阶段 -> 对BeanDefinition进行解析
  
    (1) 面向资源BeanDefinition解析
      BeanDefinitionReader
      XML解析器 - BeanDefinitionParser
      
    (2) 面向注解BeanDefinition解析 --> 针对某个包或者某个类进行注册或者扫描  如@ComponentScan 底层也会用到 AnnotatedBeanDefinitionReader
      AnnotatedBeanDefinitionReader 包含解析和注册
        
        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
        // 基于 Java 注解的 AnnotatedBeanDefinitionReader 的实现
        AnnotatedBeanDefinitionReader beanDefinitionReader = new AnnotatedBeanDefinitionReader(beanFactory);
        // 注册当前类（非 @Component class） -> 可以传普通类
        beanDefinitionReader.register(AnnotatedBeanDefinitionParsingDemo.class);
        // 普通的 Class 作为 Component 注册到 Spring IoC 容器后，通常 Bean 名称为 annotatedBeanDefinitionParsingDemo
        // Bean 名称生成来自于 BeanNameGenerator，注解实现 AnnotationBeanNameGenerator
    
  3、Spring Bean注册阶段 -> BeanDefinition注册
    BeanDefinition注册接口
      BeanDefinitionRegistry接口 -> 
        唯一实现DefaultListableBeanFactory
          方法:registerBeanDefinition
            this.beanDefinitionMap.put(beanName, beanDefinition);//用于注册 key - value(String - BeanDefinition)
				    this.beanDefinitionNames.add(beanName);//用于维持顺序
      
  4、Spring BeanDefinition合并阶段 -> 每个BeanDefinition对应一个class，class会经过ClassLoader加载
    
    rootBeanDefinition不存在parent定义，不需要合并
    普通BeanDefinition，genericBeanDefinition，有父类型时需要合并
    经过合并，genericBeanDefinition变成了rootBeanDefinition，并且覆盖parent相关配置
    
    ConfigurableBeanDefinition -> getMergedBeanDefinition
    
    BeanDefinition合并
      父子BeanDefinition合并 -> 继承配置
        当前BeanFactory查找
        层次性BeanFactory查找
        
    没有继承的Bean定义最终会生成RootBeanDefinition，这种BeanDefinition不需要合并，禁止对setParentName方法设置值。
    而存在parent的Bean定义则生成的是普通的GenericBeanDefinition，需要合并parent的BeanDefinition属性。
    AbstractBeanFactory的getMergedBeanDefinition(String beanName)方法提供了BeanDefinition的合并逻辑的实现。
    执行最终合并的是其中的mbd.overrideFrom(bd),将子bean和父bean的属性进行合并。
    
    在RootBeanDefinition的基础上，添加或者修改成子类的属性。
    最终parentBeanDefinition和subBeanDefinition都一起成为了RootBeanDefinition，保存在mergedBeanDefinitions的缓存里。
    
  5、Spring Bean Class加载阶段
    ClassLoader类加载
      loadClass
    
    Java Security安全机制
    
    ConfigurableBeanFactory临时ClassLoader -> BeanClassLoader能被替换
        当前BeanFactory的classLoader
          ClassLoader beanClassLoader = getBeanClassLoader()
        
        ClassLoader dynamicLoader = beanClassLoader
        dynamicLoader
        
        resolveBeabClass(ClassLoader classLoader) -> 通常是通过java的classLoader加载
        String/Class? -> Class  
        
        
  6、Spring Bean 实例化前阶段
    实例化 -> class 变为对象
    非主流生命周期 - Bean实例化前阶段
      InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
        在实例化之前进行，可能会返回一个代理，替换当前的bean
				
		resolveBeforeInstantiation -> 如果返回不是空，后面操作将无法进行，大部分情况下返回是空
  
  7、Spring Bean 实例化阶段 -> doCreateBean阶段 ***************************************
     实例化方式  
     (1) 传统实例化方式
        实例化策略 - InstantiationStrategy
					BeanWrapper -> 实例的包装对象
					传统实现方法  
						方法一 private InstantiationStrategy instantiationStrategy = new CglibSubclassingInstantiationStrategy();
						方法二 SimpleInstantiationStrategy -> 无参构造器的实现	 
     
     (2) 构造器依赖注入 Autowire
		 		按类型找->通过限定符@Qualifier过滤->@Primary->@Priority->根据名称找（字段名称或者参数名称）
     
		 想要生成一个 Bean，那么需要先根据其 Class 对象创建一个 Bean 的实例对象，然后进行一系列的初始化工作。
		 在创建 Bean 的实例对象的过程中，传统的实例化方式（大多数情况）使用 InstantiationStrategy 这个接口来实现，获取默认构造器，然后通过它创建一个实例对象。
		 还有一种方式就是需要通过构造器注入相关的依赖对象，首先会获取构造器中的参数对象（依赖注入，入口：DefaultListableBeanFactory#resolveDependency，前面已经分析过了），
		 根据这些需要注入的依赖对象，通过指定的构造器创建一个实例对象。
     
  8、Spring Bean 实例化后阶段 -> Bean属性赋值的判断，赋值的前置操作
		Bean属性赋值(Populate)判断
			InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation
				返回true，bean中的属性应该被设置，否则就跳过设置
				
  9、Spring Bean 属性赋值前阶段 -> 配置元信息转换为属性的值
  
	
  10、Spring Bean Aware接口回调阶段
	
  
  11、Spring Bean 初始化前阶段
	
  
  12、Spring Bean 初始化阶段
	
  
  13、Spring Bean 初始化后阶段
	
  
  14、Spring Bean 初始化完成阶段
	
  
  15、Spring Bean 销毁前阶段
	
  
  16、Spring Bean 销毁阶段
	
  
  17、Spring Bean 垃圾收集
	
  
  
  DefaultListableBeanFactory
    默认实现了ListableBeanFactory和BeanDefinitionRegistry接口
    
    
Spring配置元信息
  1、Spring配置元信息
  2、Spring Bean配置元信息 BeanDefinition
  3、Spring Bean属性元信息 PropertyValues
  4、Spring容器配置元信息
  5、基于XML资源装载Spring Bean配置元信息
  6、基于Java 注解装载Spring Bean配置元信息
  7、Spring Bean配置元信息底层实现 XML资源
  8、Spring Bean配置元信息底层实现 Java注解
  9、基于XML资源装载Spring IoC容器配置元信息
  10、基于Java 注解装载Spring IoC容器配置元信息
  11、基于Extensible XML authoring扩展Spring XML元素
  12、Extensible XML authoring扩展原理
  13、基于Properties资源装载外部化配置
  14、基于YAML资源装载外部化配置

  
Spring资源管理
  1、
  2、
  3、
  4、
  5、
  6、
  7、
  8、
  9、
  10、
  
Spring国际化
  1、
  2
  3
  4
  5
  6
  7
  8

Spring校验
  1
  2
  3
  4
  5
  6
  
Spring数据绑定
  1
  2
  3
  4
  5
  6
  7
  8
  
Spring类型转换
  1
  2
  3
  4
  5
  6
  7
  8
  9
  10
  11
  12
  13
  14
  
Spring泛型处理
  1
  2
  3
  4
  5
  6
  7
  
Spring事件
  1
  2
  3
  4
  5
  6
  7
  8
  9
  10
  11
  12
  13
  14
  15
  16
  17
  18
  19
  
Spring注解 Annotations
  1、Spring注解驱动编程发展历程
  
  2、Spring核心注解场景分类
    Spring模式注解	 
		Spring注解                   场景说明            起始版本
		@Reposity                数据仓储模式注解           2.0
		@Component               通用组件模式注解           2.5
		@Service                 服务模式注解              2.5
		@Controller              Web控制器模式注解         2.5
		@Configuration           配置类模式注解            3.0
		
    装配注解
		Spring注解                   场景说明                            起始版本
		@ImportResource          替换XML元素<import>                      2.5
		@Import                  导入Configuration类                      2.5
		@ComponentScan           扫描指定package下标注Spring模式注解的类      3.1

  	依赖注入注解
		Spring注解                   场景说明                起始版本
		@Autowired       Bean依赖注入，支持多种依赖查找方式       2.5
		@Qualifier       细粒度的@Autowired依赖查找             2.5
		
  3、Spring注解编程模型
		编程模型
			元注解 Meta-Annotations -> 标注在注解上的注解
			
			Spring模式注解 Stereotype Annotations -> @Component及其派生
			
			Spring组合注解 Composed Annotations
			
			Spring注解属性别名和覆盖 Attribute Aliases and Overrides
	
  
  4、Spring元注解 Meta-Annotations 
	  例如
			java.lang.annotation.Documented
				@Documented
				@Retention(RetentionPolicy.RUNTIME) //预留在什么地方
				@Target(ElementType.ANNOTATION_TYPE) //标注类型
				public @interface Documented{}
			java.lang.annotation.Inherited
				@Inherited //可以继承
				@Retention(RetentionPolicy.RUNTIME) //预留在什么地方
				@Target(ElementType.ANNOTATION_TYPE) //标注类型
				public @interface Inherited{}
			java.lang.annotation.Repeatable
				@Repeatable //在一个target可以使用多次
				@Retention(RetentionPolicy.RUNTIME) //预留在什么地方
				@Target(ElementType.ANNOTATION_TYPE) //标注类型
				public @interface Repeatable{
					Class<? extends Annotation> value();
				}

  
  5、Spring模式注解 Stereotype Annotations
		
  
  6、Spring组合注解 Composed Annotations
  
  7、Spring注解属性别名 Attribute Aliases 
  
  8、Spring注解属性覆盖 Attribute Overrides
  
  9、Spring @Enable模块驱动
  
  10、Spring条件注解
    @Profile
    @Conditional
  
  11、Spring Boot和Spring Cloud是怎样在Spring注解内核上扩展的
  
Spring Environment抽象
  1、理解Spring Environment抽象
  2、Spring Environment接口使用场景
  3、Environment占位符处理
  4、理解条件配置Spring Profiles
  5、Spring 4重构@Profile
  6、依赖注入Environment
  7、依赖查找Environment
  8、依赖注入@Value
  9、Spring类型转换在@Value中的运用
  10、Spring配置属性源PropertySource
  11、Spring内建的配置属性源
  12、基于注解扩展Spring配置属性源
  13、基于API扩展Spring外部化配置属性源
  14、Spring4.1测试配置属性源 @TestPropertySource
  
Spring应用上下文生命周期
  1、Spring应用上下文启动准备阶段
  2、BeanFactory创建阶段
  3、BeanFactory准备阶段
  4、BeanFactory后置处理阶段
  5、BeanFactory注册BeanpostProcessor
  6、初始化内建Bean: MessageSource
  7、初始化内建Bean: Spring事件广播器
  8、Spring应用上下文刷新阶段
  9、Spring事件监听器注册阶段
  10、BeanFactory初始化完成阶段
  11、Spring应用上下文刷新完成阶段
  12、Spring应用上下文启动阶段
  13、Spring应用上下文停止阶段
  14、Spring应用上下文关闭阶段

  
